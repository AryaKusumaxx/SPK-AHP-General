import type { Writable, Readable } from 'svelte/store';
declare type WithPreviousOptions<T, N extends number> = {
    numToTrack?: N;
    initPrevious?: Array<T>;
    requireChange?: boolean;
    isEqual?: IsEqual<T>;
};
declare type WithPreviousResult<T, N extends number> = [
    Writable<T>,
    ...Tuple<Readable<T | null>, N>
];
export declare function withPrevious<T, N extends number = 1>(initValue: T, { numToTrack, initPrevious, requireChange, isEqual, }?: WithPreviousOptions<T, N>): WithPreviousResult<T, N>;
/**
 * @deprecated Since version 2.0.1. Use `withPrevious` instead.
 */
export declare const usePrevious: typeof withPrevious;
declare type IsEqual<T> = (a: T, b: T) => boolean;
/**
 * Adopted from https://github.com/microsoft/TypeScript/issues/26223#issuecomment-674514787
 */
declare type BuildPowersOf2LengthArrays<N extends number, R extends never[][]> = R[0][N] extends never ? R : BuildPowersOf2LengthArrays<N, [[...R[0], ...R[0]], ...R]>;
declare type ConcatLargestUntilDone<N extends number, R extends never[][], B extends never[]> = B['length'] extends N ? B : [...R[0], ...B][N] extends never ? ConcatLargestUntilDone<N, R extends [R[0], ...infer U] ? (U extends never[][] ? U : never) : never, B> : ConcatLargestUntilDone<N, R extends [R[0], ...infer U] ? (U extends never[][] ? U : never) : never, [
    ...R[0],
    ...B
]>;
declare type Replace<R extends unknown[], T> = {
    [K in keyof R]: T;
};
declare type Tuple<T, N extends number> = number extends N ? T[] : {
    [K in N]: BuildPowersOf2LengthArrays<K, [[never]]> extends infer U ? U extends never[][] ? Replace<ConcatLargestUntilDone<K, U, []>, T> : never : never;
}[N];
export {};
